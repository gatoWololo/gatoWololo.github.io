<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>wololo!</title>
        <link>https:&#x2F;&#x2F;gatowololo.github.io</link>
        <description>Much ado about programming</description>
        <generator>Gutenberg</generator>
        <language>en</language>
        <atom:link href="https:&#x2F;&#x2F;gatowololo.github.io&#x2F;rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Mon, 18 Jun 2018 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Blog List</title>
                <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
                <link>https:&#x2F;&#x2F;gatowololo.github.io&#x2F;blog&#x2F;main&#x2F;</link>
                <guid>https:&#x2F;&#x2F;gatowololo.github.io&#x2F;blog&#x2F;main&#x2F;</guid>
                <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;gatowololo.github.io&#x2F;blog&#x2F;ptraceintro&#x2F;&quot;&gt;Ptrace &amp;amp; You: A comprehensive overview of ptrace&lt;&#x2F;a&gt;
Introduction to a multipart series on ptrace.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Ptrace and You</title>
                <pubDate>Sat, 16 Jun 2018 00:00:00 +0000</pubDate>
                <link>https:&#x2F;&#x2F;gatowololo.github.io&#x2F;blog&#x2F;ptraceintro&#x2F;</link>
                <guid>https:&#x2F;&#x2F;gatowololo.github.io&#x2F;blog&#x2F;ptraceintro&#x2F;</guid>
                <description>&lt;h2 id=&quot;ptrace&quot;&gt;Ptrace &amp; You: A comprehensive overview of ptrace&lt;&#x2F;h2&gt;
&lt;p&gt;Our current project involves heavy use of &lt;code&gt;ptrace&lt;&#x2F;code&gt;. While &lt;code&gt;man 2 ptrace&lt;&#x2F;code&gt; offers
a in depth technical description, it is very difficult to follow for begginners (hence all
the introduction to ptrace blogs around). While these blogs helped me get started, I don&#x27;t
believe any of them offers an in-depth, comprehensive view of ptrace: it&#x27;s many features and
just as many ways to shoot yourself in the foot. TODO Rewrite last sentence&lt;&#x2F;p&gt;
&lt;p&gt;I found these particular blogs helpful:
TODO Add link to:
Write you an strace, ptrace gotchas.&lt;&#x2F;p&gt;
&lt;p&gt;After a year of using &lt;code&gt;ptrace&lt;&#x2F;code&gt;, I hope to have something useful to say about ptrace. For
those trying to understand it, and hopefully make it easier to break through the
description on the man page.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-is-ptrace&quot;&gt;What is ptrace?&lt;&#x2F;h3&gt;
&lt;p&gt;Ptrace is a Linux system call which allows a process (known as the &lt;em&gt;tracer&lt;&#x2F;em&gt;) to trace
another process (the &lt;em&gt;tracee&lt;&#x2F;em&gt;) through ptrace, the tracer can intercept events in the
&lt;em&gt;tracee&lt;&#x2F;em&gt; such as: system calls, signals, execves, and more.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;em&gt;tracer&lt;&#x2F;em&gt; can also read and write to arbitrary locations in: program memory, or CPU
registers, of the &lt;em&gt;tracee&lt;&#x2F;em&gt;. This functionality is very powerful, programs such as gdb and
strace use ptrace under the hood!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ptrace-at-the-kernel-level&quot;&gt;Ptrace at the kernel level&lt;&#x2F;h3&gt;
&lt;p&gt;From the Linux man page (TODO add link), &amp;quot;The ptrace API (ab)uses the standard UNIX
parent&#x2F;child  signaling  over  waitpid(2).&amp;quot;&lt;&#x2F;p&gt;
&lt;p&gt;Ptrace, in some ways, replaces the &lt;em&gt;tracee&lt;&#x2F;em&gt;&#x27;s true parent with our &lt;em&gt;tracer&lt;&#x2F;em&gt;. When one
of many ptrace events happens, the kernel puts the &lt;em&gt;tracee&lt;&#x2F;em&gt; in a stopped state, forwards
the message to the &lt;em&gt;tracer&lt;&#x2F;em&gt;, the tracer may perform arbitrary computation here. The
&lt;em&gt;tracer&lt;&#x2F;em&gt; then sends one of several ptrace continue events through a &lt;code&gt;ptrace&lt;&#x2F;code&gt; system call,
the kernel allows the currently stopped &lt;em&gt;tracee&lt;&#x2F;em&gt; to run once more.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ptrace-overhead&quot;&gt;Ptrace overhead&lt;&#x2F;h3&gt;
&lt;p&gt;Ptrace is not known to be fast, and inccurs significant overhead. (TODO: Add over head
measurement here). The overhead comes from the number of context switches required to
intercept an event. Consider a system call event, usually this is requires two context
switches: userspace to kernelspace, and back to userspace. With &lt;code&gt;ptrace&lt;&#x2F;code&gt; this is doubled:
&lt;em&gt;tracee&lt;&#x2F;em&gt; to kernel, kernel to &lt;em&gt;tracer&lt;&#x2F;em&gt;, &lt;em&gt;tracer&lt;&#x2F;em&gt; to kernel, and kernel to &lt;em&gt;tracee&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-ptrace&quot;&gt;Using ptrace&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s have a look at the &lt;code&gt;ptrace&lt;&#x2F;code&gt; system call API:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fdf6e3&quot;&gt;
&lt;span style=&quot;background-color:#fdf6e3;color:#268bd2;&quot;&gt;long &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#b58900;&quot;&gt;ptrace&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#657b83;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#268bd2;&quot;&gt;enum&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#657b83;&quot;&gt; __ptrace_request &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#268bd2;&quot;&gt;request&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#657b83;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#859900;&quot;&gt;pid_t &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#268bd2;&quot;&gt;pid&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#657b83;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#268bd2;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#859900;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#268bd2;&quot;&gt;addr&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#657b83;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#268bd2;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#859900;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#268bd2;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#fdf6e3;color:#657b83;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As we will see, a lot of functionality and complexity is packed into this API.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;future-ptrace-blog-posts&quot;&gt;Future Ptrace Blog Posts&lt;&#x2F;h3&gt;
&lt;p&gt;In the future I hope to also create blog posts for:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;System call tracing with ptrace&lt;&#x2F;li&gt;
&lt;li&gt;Selectively Tracing System Calls: Using ptrace with seccomp&lt;&#x2F;li&gt;
&lt;li&gt;Ptrace with multiprocesses&lt;&#x2F;li&gt;
&lt;li&gt;Ptrace and signals&lt;&#x2F;li&gt;
&lt;li&gt;Ptrace with threads&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>About me</title>
                <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
                <link>https:&#x2F;&#x2F;gatowololo.github.io&#x2F;about&#x2F;about&#x2F;</link>
                <guid>https:&#x2F;&#x2F;gatowololo.github.io&#x2F;about&#x2F;about&#x2F;</guid>
                <description>&lt;h2 id=&quot;work&quot;&gt;Work&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;m a third year PhD student at the University Of Pennsylvania. I&#x27;m part of the Architecture and Compilers Group (ACG), advised by &lt;a href=&quot;https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;%7Edevietti&#x2F;&quot;&gt;Joseph Devietti&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;A PhD program gives me the freedom to work on super cool research projects, explore new technologies and experimental designs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;research-interests&quot;&gt;Research interests&lt;&#x2F;h2&gt;
&lt;p&gt;I am interested in all matters related to systems programming. Mainly, how can we make systems programming easier in terms of productiviy, security, and correctness.&lt;&#x2F;p&gt;
&lt;p&gt;As parallelism becomes increasingly needed to keep up with the demands of software, I plan to focus on methods for easier, portable, and correct parallel and concurrent programming.&lt;&#x2F;p&gt;
&lt;p&gt;I view Rust as the great next step in the right direction! I&#x27;m excited to program future research projects in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m also very interested in operating systems, compilers, and programming languages (specially the functional kind).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;teaching&quot;&gt;Teaching&lt;&#x2F;h2&gt;
&lt;p&gt;In the past, I have TA Penn&#x27;s the graduate Haskell programming class.&lt;&#x2F;p&gt;
&lt;p&gt;For the fall 2018 semester I am beyond excited to teach UPenn&#x27;s Rust programming course!&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
